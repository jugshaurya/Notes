---
title: 7. Dynamic Programming
sidebar_position: 7
tags: [DP]
---

---

## Dynamic Programming (DP)

-   All about remembering the past.
-   `Optimal Substructure`
    -   Can express bigger problem in small sub-problems of the same type (Recurrence Relation).
    -   This property is also available in Divide and Conquer, all recursion problems.
-   `Overlapping Subproblem`
    -   This property is the giveaway that the given problem is a DP problem.
-   üíé - Important
-   ‚úî - Done
-   üåü - Do once more

## Some Initialization Points

---

```cpp
  // In global scope
  vector<int> dp;
  int n;

  void solve (){
    // resetting dp array for every test case
    dp.clear();
    dp.resize(n);
    dp.assign(n,0); // or dp = vector<int>(n,0);
  }

  int main(){
    int t; cin>>t; while(t--) solve();
  }
```

### General structure of DP functions

---

```cpp
int dp[N][M]; // dp array
// function with state and constraints
// In knapsack,
// form state:  the index we are currently working in our problem.
// constraint state:  W, we cannot go above bags Weight.
function rec (<form state(s)>, <constraint state(s)>){
  // Pruning cases
  // Base cases
  // cache check
  // recursive code and computation
  // save and return
}
```

-   Note:
    -   `Estimated` Time complexity of DP problems = `#states * (1 + Average cost of transitions)`
    -   `Exact` Time complexity of DP problems = `Total transition time for all states.`
    -   Space complexity of DP problems = `#states * space required for each state`
-   Transitions means number of recursive calls.
-   Cost of Transition = extra time taken besides recusive calls.
-   #states are is basically DP array size.

-   Note2:
    -   In DP problems, we need to think/practise finding states(both form and constraints) and transitions needed to solve the problem.

### 1-D DP

---

-   Fibonacci Number ‚úî
    -   Recursive, Time: O(2<sup>n</sup>), Space: O(n) Stack Space.
    -   Top Down(Recursive + Memoization) : Time: O(n), Space: O(n) Stack Space, O(n) dp array space.
    -   Bottom Up DP: Time: O(n), Space: O(n) dp array.
    -   Bottom Up DP: Space optimzed: Time: O(n), Space: O(1) as only last two past things are to be remembered.
    -   `TODO:` Via Matrix Exponentiation: Time: O(logn), See in advance-ds.md file.
    -   `TODO:` Binet's Formula, Works for small fib numbers. Formula = (phi^n - (-phi)^(-n)) / sqrt(5)
    -   `TODO:` [Codeforces Hack](https://codeforces.com/blog/entry/14516/) - O(logn \* loglogn)
        -   If n is even, f(n) = f(n/2)_f(n/2) - f(n/2-1)_ f(n/2-1) ;i.e. half<sup>2</sup> - (half-1)<sup>2</sup>
        -   If n is odd, f(n) = f(n/2)_f(n/2+1) - f(n/2)_ f(n/2-1) ;i.e. half*(half+1) - half*(half-1)
    -   Properties of Fibonacci Numbers
        1. **Sum of first N fibonacci number** = (n+2)th Fibonacci - 1
        -   F0 + F1 + F2 + ... + Fn = F(n+2) - 1
        2. **Sum of square of first N fibonacci Numbers** is Product of F(n)\*F(n+1)
        -   (F0)<sup>2</sup> + (F1)<sup>2</sup> + (F2)<sup>2</sup> + ... + (Fn)<sup>2</sup> + = Fn\*F(n+1)
        3. GCD of two fibonacci numbers(nth and mth) is the gcd(n,m)th Fibonacci number
        -   gcd(Fn,Fm) = F(gcd(n,m))
-   Min Coin Change ‚úî
-   Min Steps to One ‚úî
-   Count Number of Binary strings with no 1s together (no two ones are consecutive) ‚úî
-   Friends Pairing ‚úî
-   Maximum Subarray Sum ‚úî
    -   Kadane's Algorithm
-   Ladder ‚úî
    -   #ways to reach nth step given we can jump upto k steps. Also 121 and 211 are seperate cases.

### 2-D DP

---

-   Wines Problem ‚úî
-   Catalan Number ‚úî
-   Ways to make Coin change of money using coins array üåü ‚úî
    -   Min Coin Change ‚úî is a different problem as: here we are required to find the number of ways to make changes, out of which one is the minimum answer and that was the min coin change problem.
-   #ways to get change of n, withour permutations
    -   dp(i, taken) = dp(i-taken, taken) + dp(i, taken + 1);
-   Maximum subarray sum
    -   dp(ending_at_i) = arr[i] + max(0, dp(i-1));
-   Knapsack

    -   0/1
    -   Fractional Knapsack
    -   Colourful Knapsack

-   LIS

    -   n<sup>2</sup>
    -   nlogn approach [** To be Done]

-   LCS with one array having only distinct elements
    -   reduces to LIS
-   General LCS

    -   O(n<sup>2</sup>)

-   Selecting items from either ends
    -   dp(i,j)

### Facts

-   Overlapping subproblems
-   Optimal substructure.
-   states
-   Transitions
-   what does dp(states) represent?
-   Base Cases: Basically when/where does your transition equation fails?

| Recursive                              | Iterative                                                                                                       |
| -------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| Slower                                 | Faster                                                                                                          |
| No need to care about the flow         | Important to calculate states in a way that <br/> current state can be derived from previously calculated state |
| ‚≠ê Doesn't evaluate unnecessary states | All states are evaluated.                                                                                       |
| cannot apply many optimizations        | can apply many optimizations                                                                                    |
